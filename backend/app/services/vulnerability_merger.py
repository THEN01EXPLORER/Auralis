"""
Vulnerability Merger Service

This service handles the intelligent merging of vulnerabilities from multiple sources
(static analysis and AI analysis) to eliminate duplicates and combine insights.
"""

import logging
from typing import List
from ..models.contract import Vulnerability

logger = logging.getLogger(__name__)


class VulnerabilityMerger:
    """
    Service for merging vulnerabilities from static and AI analysis sources.
    
    Handles deduplication by comparing vulnerability type and line number,
    then intelligently combines duplicate vulnerabilities by selecting the
    highest severity and confidence while merging descriptions.
    """
    
    @staticmethod
    def merge(static_vulns: List[Vulnerability], ai_vulns: List[Vulnerability]) -> List[Vulnerability]:
        """
        Merges vulnerabilities from static and AI analysis.
        
        Deduplication logic:
        - Same type + same line = merge
        - Take highest severity
        - Take highest confidence
        - Combine descriptions with clear attribution
        - Mark merged vulnerabilities with source="hybrid"
        
        Args:
            static_vulns: List of vulnerabilities from static analysis
            ai_vulns: List of vulnerabilities from AI analysis
            
        Returns:
            Deduplicated list of vulnerabilities
        """
        logger.debug(f"Starting vulnerability merge - Static: {len(static_vulns)}, AI: {len(ai_vulns)}")
        
        if not static_vulns and not ai_vulns:
            logger.debug("No vulnerabilities to merge")
            return []
        
        if not static_vulns:
            logger.debug("No static vulnerabilities, returning AI vulnerabilities only")
            return ai_vulns
        
        if not ai_vulns:
            logger.debug("No AI vulnerabilities, returning static vulnerabilities only")
            return static_vulns
        
        merged_vulns = []
        ai_vulns_copy = ai_vulns.copy()
        duplicates_found = 0
        
        # Process each static vulnerability
        for static_vuln in static_vulns:
            duplicate_found = False
            
            # Check if this static vulnerability has a duplicate in AI results
            for i, ai_vuln in enumerate(ai_vulns_copy):
                if VulnerabilityMerger._is_duplicate(static_vuln, ai_vuln):
                    # Log duplicate detection
                    logger.debug(f"Duplicate detected: {static_vuln.type} at line {static_vuln.line}")
                    
                    # Merge the two vulnerabilities
                    merged_vuln = VulnerabilityMerger._merge_two(static_vuln, ai_vuln)
                    merged_vulns.append(merged_vuln)
                    
                    # Remove the AI vulnerability from the copy to avoid double processing
                    ai_vulns_copy.pop(i)
                    duplicate_found = True
                    duplicates_found += 1
                    
                    logger.debug(f"Merged duplicate: severity {static_vuln.severity} + {ai_vuln.severity} -> {merged_vuln.severity}, "
                               f"confidence {static_vuln.confidence} + {ai_vuln.confidence} -> {merged_vuln.confidence}")
                    break
            
            # If no duplicate found, add the static vulnerability as-is
            if not duplicate_found:
                merged_vulns.append(static_vuln)
        
        # Add remaining AI vulnerabilities that had no duplicates
        unique_ai_vulns = len(ai_vulns_copy)
        merged_vulns.extend(ai_vulns_copy)
        
        logger.info(f"Vulnerability merge completed - Input: {len(static_vulns)} static + {len(ai_vulns)} AI = {len(static_vulns) + len(ai_vulns)} total")
        logger.info(f"Merge results - {duplicates_found} duplicates merged, {unique_ai_vulns} unique AI vulnerabilities, final count: {len(merged_vulns)}")
        
        # Log detailed merge statistics for monitoring and optimization
        if duplicates_found > 0:
            deduplication_rate = (duplicates_found / (len(static_vulns) + len(ai_vulns))) * 100
            logger.debug(f"Deduplication statistics - Rate: {deduplication_rate:.1f}%, "
                        f"Efficiency: {duplicates_found} duplicates removed from {len(static_vulns) + len(ai_vulns)} total")
        
        # Log severity distribution of final merged results
        severity_counts = {"Critical": 0, "High": 0, "Medium": 0, "Low": 0}
        source_counts = {"static": 0, "ai": 0, "hybrid": 0}
        
        for vuln in merged_vulns:
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
            source_counts[vuln.source] = source_counts.get(vuln.source, 0) + 1
        
        severity_summary = ", ".join([f"{count} {severity}" for severity, count in severity_counts.items() if count > 0])
        source_summary = ", ".join([f"{count} {source}" for source, count in source_counts.items() if count > 0])
        
        if severity_summary:
            logger.debug(f"Final vulnerability severity distribution: {severity_summary}")
        if source_summary:
            logger.debug(f"Final vulnerability source distribution: {source_summary}")
        
        return merged_vulns
    
    @staticmethod
    def _is_duplicate(v1: Vulnerability, v2: Vulnerability) -> bool:
        """
        Determines if two vulnerabilities are duplicates.
        
        Two vulnerabilities are considered duplicates if they have:
        - Same vulnerability type
        - Same line number
        
        Args:
            v1: First vulnerability
            v2: Second vulnerability
            
        Returns:
            True if vulnerabilities are duplicates, False otherwise
        """
        return v1.type == v2.type and v1.line == v2.line
    
    @staticmethod
    def _merge_two(v1: Vulnerability, v2: Vulnerability) -> Vulnerability:
        """
        Merges two duplicate vulnerabilities into a single vulnerability.
        
        Merging logic:
        - Use highest severity (Critical > High > Medium > Low)
        - Use highest confidence score
        - Combine descriptions from both sources with attribution
        - Set source to "hybrid"
        - Preserve remediation details if available
        
        Args:
            v1: First vulnerability (typically from static analysis)
            v2: Second vulnerability (typically from AI analysis)
            
        Returns:
            Merged vulnerability with combined information
        """
        logger.debug(f"Merging vulnerabilities: {v1.type} at line {v1.line} - "
                    f"Static({v1.severity}, {v1.confidence}) + AI({v2.severity}, {v2.confidence})")
        
        # Define severity hierarchy for comparison
        severity_order = {"Critical": 4, "High": 3, "Medium": 2, "Low": 1}
        
        # Select highest severity
        v1_severity_level = severity_order.get(v1.severity, 0)
        v2_severity_level = severity_order.get(v2.severity, 0)
        
        if v1_severity_level >= v2_severity_level:
            merged_severity = v1.severity
            severity_source = "static" if v1.source == "static" else "AI"
        else:
            merged_severity = v2.severity
            severity_source = "AI" if v2.source == "ai" else "static"
        
        # Select highest confidence
        merged_confidence = max(v1.confidence, v2.confidence)
        confidence_source = "static" if v1.confidence >= v2.confidence else "AI"
        
        logger.debug(f"Merge decisions - Severity: {merged_severity} (from {severity_source}), "
                    f"Confidence: {merged_confidence} (from {confidence_source})")
        
        # Combine descriptions with clear attribution
        v1_source_label = "Static Analysis" if v1.source == "static" else "AI Analysis"
        v2_source_label = "Static Analysis" if v2.source == "static" else "AI Analysis"
        
        merged_description = f"{v1_source_label}: {v1.description}\n\n{v2_source_label}: {v2.description}"
        
        # Combine recommendations
        merged_recommendation = f"{v1_source_label}: {v1.recommendation}\n\n{v2_source_label}: {v2.recommendation}"
        
        # Use remediation from AI analysis if available, otherwise from static
        merged_remediation = v2.remediation if v2.remediation else v1.remediation
        if merged_remediation:
            remediation_source = "AI" if v2.remediation else "static"
            logger.debug(f"Using remediation details from {remediation_source} analysis")
        
        # Create merged vulnerability
        return Vulnerability(
            type=v1.type,  # Type should be the same for duplicates
            severity=merged_severity,
            line=v1.line,  # Line should be the same for duplicates
            description=merged_description,
            recommendation=merged_recommendation,
            confidence=merged_confidence,
            source="hybrid",
            remediation=merged_remediation
        )