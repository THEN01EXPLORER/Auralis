import * as vscode from 'vscode';
import { AnalysisResult, Vulnerability } from './analyzer';

export class VulnerabilityTreeProvider implements vscode.TreeDataProvider<VulnerabilityItem> {
    private _onDidChangeTreeData = new vscode.EventEmitter<VulnerabilityItem | undefined>();
    readonly onDidChangeTreeData = this._onDidChangeTreeData.event;

    private vulnerabilities: Map<string, AnalysisResult> = new Map();

    updateVulnerabilities(uri: vscode.Uri, result: AnalysisResult) {
        this.vulnerabilities.set(uri.toString(), result);
        this._onDidChangeTreeData.fire(undefined);
    }

    getTreeItem(element: VulnerabilityItem): vscode.TreeItem {
        return element;
    }

    getChildren(element?: VulnerabilityItem): VulnerabilityItem[] {
        if (!element) {
            // Root level: show files
            const items: VulnerabilityItem[] = [];
            
            this.vulnerabilities.forEach((result, uriString) => {
                const uri = vscode.Uri.parse(uriString);
                const fileName = uri.path.split('/').pop() || 'Unknown';
                
                const item = new VulnerabilityItem(
                    `${fileName} (${result.vulnerabilities.length} issues)`,
                    vscode.TreeItemCollapsibleState.Expanded,
                    'file',
                    result
                );
                item.iconPath = new vscode.ThemeIcon('file-code');
                item.description = `Risk: ${result.risk_score}`;
                items.push(item);
            });

            return items;
        } else if (element.type === 'file' && element.result) {
            // Group by severity
            const grouped = this.groupBySeverity(element.result.vulnerabilities);
            const items: VulnerabilityItem[] = [];

            for (const [severity, vulns] of Object.entries(grouped)) {
                const item = new VulnerabilityItem(
                    `${severity} (${vulns.length})`,
                    vscode.TreeItemCollapsibleState.Expanded,
                    'severity',
                    undefined,
                    vulns
                );
                item.iconPath = this.getSeverityIcon(severity);
                items.push(item);
            }

            return items;
        } else if (element.type === 'severity' && element.vulnerabilities) {
            // Show individual vulnerabilities
            return element.vulnerabilities.map(vuln => {
                const item = new VulnerabilityItem(
                    `Line ${vuln.line}: ${vuln.type}`,
                    vscode.TreeItemCollapsibleState.None,
                    'vulnerability',
                    undefined,
                    undefined,
                    vuln
                );
                item.description = vuln.description;
                item.tooltip = `${vuln.description}\n\nRecommendation: ${vuln.recommendation}`;
                item.command = {
                    command: 'auralis.applyFix',
                    title: 'Apply Fix',
                    arguments: [vuln]
                };
                return item;
            });
        }

        return [];
    }

    private groupBySeverity(vulnerabilities: Vulnerability[]): Record<string, Vulnerability[]> {
        const grouped: Record<string, Vulnerability[]> = {};
        
        for (const vuln of vulnerabilities) {
            if (!grouped[vuln.severity]) {
                grouped[vuln.severity] = [];
            }
            grouped[vuln.severity].push(vuln);
        }

        return grouped;
    }

    private getSeverityIcon(severity: string): vscode.ThemeIcon {
        switch (severity.toLowerCase()) {
            case 'critical':
                return new vscode.ThemeIcon('error', new vscode.ThemeColor('errorForeground'));
            case 'high':
                return new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground'));
            case 'medium':
                return new vscode.ThemeIcon('info', new vscode.ThemeColor('editorInfo.foreground'));
            default:
                return new vscode.ThemeIcon('circle-outline');
        }
    }
}

class VulnerabilityItem extends vscode.TreeItem {
    constructor(
        public readonly label: string,
        public readonly collapsibleState: vscode.TreeItemCollapsibleState,
        public readonly type: 'file' | 'severity' | 'vulnerability',
        public readonly result?: AnalysisResult,
        public readonly vulnerabilities?: Vulnerability[],
        public readonly vulnerability?: Vulnerability
    ) {
        super(label, collapsibleState);
    }
}
